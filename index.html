<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>사주 MVP2</title>
  <style>
    :root{
      --bg: #f6f7fb;
      --card: #ffffff;
      --text: #101828;
      --sub: #667085;
      --line: #e6e8f0;
      --primary: #6d5efc;
      --primary2: #37b3ff;
      --chip: #f1f4ff;
      --shadow: 0 10px 30px rgba(16,24,40,.08);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    html, body{ width:100%; }
    body{
      margin:0;
      background: radial-gradient(900px 500px at 10% 0%, #eef0ff, transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, #e7f6ff, transparent 55%),
                  var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 18px;
    }
    .wrap{ width:min(980px, 100%); margin:0 auto; display:grid; gap:14px; }
    .topbar{
      background: linear-gradient(135deg, rgba(109,94,252,.12), rgba(55,179,255,.10));
      border: 1px solid rgba(109,94,252,.18);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: var(--shadow);
    }
    .title{ margin:0; font-size: clamp(20px, 3.2vw, 28px); letter-spacing:-.02em; }
    .subtitle{ margin:6px 0 0; color: var(--sub); font-size: 14px; line-height:1.45; }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h2{
      margin:0 0 10px;
      font-size: 16px;
      letter-spacing:-.01em;
    }
    .grid{
      display:grid; gap:12px;
      grid-template-columns: 1fr 1fr;
      align-items: start;
    }
    @media (max-width: 820px){
      .grid{ grid-template-columns: 1fr; }
    }

    /* ====== Picker (숫자 스크롤) ====== */
    .pickerGroup{ display:grid; gap:8px; }
    .labelRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .label{ font-size: 13px; color: var(--sub); }
    .hint{ font-size: 12px; color: var(--sub); }

    .wheelRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .wheelRow.two{ grid-template-columns: 1fr 1fr; }
    .wheel{
      position: relative;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #fff;
      overflow: hidden;
      height: 148px;
    }
    .wheel::before, .wheel::after{
      content:"";
      position:absolute; left:0; right:0;
      height: 40px;
      pointer-events:none;
      z-index:2;
    }
    .wheel::before{
      top:0;
      background: linear-gradient(#fff, rgba(255,255,255,0));
    }
    .wheel::after{
      bottom:0;
      background: linear-gradient(rgba(255,255,255,0), #fff);
    }
    .wheelMid{
      position:absolute; left:10px; right:10px;
      top: 50%;
      height: 38px;
      transform: translateY(-50%);
      border-radius: 12px;
      background: rgba(109,94,252,.08);
      border: 1px solid rgba(109,94,252,.18);
      z-index:1;
      pointer-events:none;
    }
    select.wheelSelect{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      padding: 48px 10px;
      border:0;
      outline:none;
      background: transparent;
      appearance: none;
      -webkit-appearance: none;
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      text-align: center;
      overflow-y: auto;
    }
    select.wheelSelect option{
      font-size: 16px;
      padding: 10px 0;
      text-align:center;
    }
    .unit{
      position:absolute;
      right:10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
      color: var(--sub);
      z-index:3;
      pointer-events:none;
    }

    /* ====== Gender toggle ====== */
    .toggleRow{ display:flex; gap:10px; }
    .toggleBtn{
      flex:1;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--text);
      font-weight: 800;
      cursor: pointer;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
    }
    .toggleBtn:active{ transform: scale(.99); }
    .toggleBtn.active{
      border-color: rgba(109,94,252,.45);
      background: rgba(109,94,252,.08);
    }

    /* ====== Buttons ====== */
    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    .btn{
      flex: 1;
      min-width: 160px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(109,94,252,.22);
      background: linear-gradient(135deg, rgba(109,94,252,.95), rgba(55,179,255,.85));
      color:#fff;
      font-weight: 900;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(109,94,252,.18);
    }
    .btn.secondary{
      background: #fff;
      color: var(--text);
      border-color: var(--line);
      box-shadow: none;
    }
    .muted{ margin:10px 0 0; color: var(--sub); font-size: 12px; line-height: 1.45; }
    .error{ color:#d92d20; font-weight:800; }

    /* ====== Result UI ====== */
    table{
      width:100%;
      border-collapse: collapse;
      border: 1px solid var(--line);
      border-radius: 14px;
      overflow:hidden;
      background: #fff;
    }
    th, td{
      padding: 12px 10px;
      border-bottom: 1px solid var(--line);
      text-align:center;
      font-weight: 800;
    }
    th{
      font-size: 12px;
      color: var(--sub);
      background: #fafbff;
      letter-spacing: .02em;
    }
    td{ font-size: 18px; }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; margin-top: 10px; }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid rgba(109,94,252,.14);
      color: #2a2f6f;
      font-size: 12px;
      font-weight: 800;
    }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: #fff;
      cursor:pointer;
      font-weight: 900;
      color: var(--sub);
    }
    .tab.active{
      color: var(--text);
      border-color: rgba(109,94,252,.35);
      background: rgba(109,94,252,.06);
    }
    .panel{
      margin-top: 12px;
      line-height: 1.65;
      color: var(--text);
      font-size: 14px;
    }
    .panel h3{
      margin: 14px 0 8px;
      font-size: 14px;
      letter-spacing: -.01em;
    }
    .panel ul{ margin: 8px 0 0 18px; padding:0; }
    .panel li{ margin: 6px 0; color: #1f2937; }
    .panel .small{ color: var(--sub); font-size: 12px; }

    .footer{
      text-align:center;
      color: var(--sub);
      font-size: 12px;
      padding: 6px 0 2px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 class="title">사주 MVP2</h1>
      <p class="subtitle">
        숫자 스크롤로 생년월일·시간 선택 → 4기둥 표 + 오행/음양/십신 요약 + (성향/직업/연애·결혼) 해석까지 한 화면에서 제공됩니다.<br>
        ※ 외부 AI 호출 없이 브라우저에서만 동작(요금 0원).
      </p>
    </div>

    <div class="card">
      <h2>정보 입력</h2>

      <div class="grid">
        <!-- 생년월일 -->
        <div class="pickerGroup">
          <div class="labelRow">
            <div class="label">생년월일(양력)</div>
            <div class="hint">숫자 스크롤로 선택</div>
          </div>

          <div class="wheelRow">
            <div class="wheel">
              <div class="wheelMid"></div>
              <select id="year" class="wheelSelect" aria-label="year"></select>
              <div class="unit">년</div>
            </div>
            <div class="wheel">
              <div class="wheelMid"></div>
              <select id="month" class="wheelSelect" aria-label="month"></select>
              <div class="unit">월</div>
            </div>
            <div class="wheel">
              <div class="wheelMid"></div>
              <select id="day" class="wheelSelect" aria-label="day"></select>
              <div class="unit">일</div>
            </div>
          </div>

          <p class="muted" id="dateMsg"></p>
        </div>

        <!-- 출생시간 + 성별 -->
        <div class="pickerGroup">
          <div class="labelRow">
            <div class="label">출생시간</div>
            <div class="hint">모르면 “모름”으로 해석</div>
          </div>

          <div class="btnRow" style="margin-top:0;">
            <button id="unknownTime" class="btn secondary" type="button">시간 모름</button>
          </div>

          <div class="wheelRow two" style="margin-top:10px;">
            <div class="wheel">
              <div class="wheelMid"></div>
              <select id="hour" class="wheelSelect" aria-label="hour"></select>
              <div class="unit">시</div>
            </div>
            <div class="wheel">
              <div class="wheelMid"></div>
              <select id="minute" class="wheelSelect" aria-label="minute"></select>
              <div class="unit">분</div>
            </div>
          </div>

          <div style="margin-top:12px;">
            <div class="labelRow">
              <div class="label">성별</div>
              <div class="hint">버튼 선택</div>
            </div>
            <div class="toggleRow" style="margin-top:8px;">
              <button id="gM" class="toggleBtn" type="button">남</button>
              <button id="gF" class="toggleBtn" type="button">여</button>
            </div>
          </div>

          <div class="btnRow">
            <button id="run" class="btn" type="button">사주 계산 & 해석</button>
            <button id="reset" class="btn secondary" type="button">초기화</button>
          </div>

          <p id="msg" class="muted"></p>
        </div>
      </div>
    </div>

    <div class="card" id="resultCard" style="display:none;">
      <h2>사주 4기둥</h2>
      <table>
        <thead>
          <tr>
            <th>년주</th><th>월주</th><th>일주</th><th>시주</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td id="y"></td><td id="m"></td><td id="d"></td><td id="h"></td>
          </tr>
        </tbody>
      </table>
      <div class="chips" id="chips"></div>
      <p class="muted" id="techNote"></p>
    </div>

    <div class="card" id="interpretCard" style="display:none;">
      <h2>해석</h2>
      <div class="tabs">
        <button class="tab active" data-tab="personality" type="button">기본 성향/성격</button>
        <button class="tab" data-tab="career" type="button">직업운</button>
        <button class="tab" data-tab="love" type="button">연애·결혼운</button>
      </div>
      <div class="panel" id="panel"></div>
    </div>

    <div class="footer">vibe coding • saju mvp2</div>
  </div>

  <script type="module">
    // 사주 계산(브라우저): manseryeok 계열 라이브러리로 4기둥 산출
    // (외부 AI 호출 없음 → 요금 0원)
    import { calculateSaju } from "https://esm.sh/@fullstackfamily/manseryeok@1.0.5";

    // ====== DOM ======
    const yearEl = document.getElementById("year");
    const monthEl = document.getElementById("month");
    const dayEl = document.getElementById("day");
    const hourEl = document.getElementById("hour");
    const minEl = document.getElementById("minute");
    const dateMsg = document.getElementById("dateMsg");

    const unknownTimeBtn = document.getElementById("unknownTime");
    const gM = document.getElementById("gM");
    const gF = document.getElementById("gF");
    const runBtn = document.getElementById("run");
    const resetBtn = document.getElementById("reset");
    const msg = document.getElementById("msg");

    const resultCard = document.getElementById("resultCard");
    const interpretCard = document.getElementById("interpretCard");
    const panel = document.getElementById("panel");
    const chipsEl = document.getElementById("chips");
    const techNote = document.getElementById("techNote");

    const tabs = Array.from(document.querySelectorAll(".tab"));
    let state = {
      gender: "",        // "M" | "F" | ""
      timeUnknown: false,
      interpretation: null
    };

    // ====== Picker populate ======
    function pad2(n){ return String(n).padStart(2, "0"); }
    function setOptions(select, items, selectedValue){
      select.innerHTML = "";
      for (const it of items){
        const opt = document.createElement("option");
        opt.value = String(it.value);
        opt.textContent = it.label;
        if (String(it.value) === String(selectedValue)) opt.selected = true;
        select.appendChild(opt);
      }
    }
    function daysInMonth(y, m){
      // m: 1-12
      return new Date(y, m, 0).getDate();
    }

    function initPickers(){
      const now = new Date();
      const curY = now.getFullYear();
      const curM = now.getMonth() + 1;
      const curD = now.getDate();

      const years = [];
      for (let y = 1900; y <= 2035; y++) years.push({ value: y, label: y });
      setOptions(yearEl, years, curY);

      const months = [];
      for (let m = 1; m <= 12; m++) months.push({ value: m, label: pad2(m) });
      setOptions(monthEl, months, curM);

      refreshDays(curY, curM, curD);

      const hours = [];
      for (let h = 0; h <= 23; h++) hours.push({ value: h, label: pad2(h) });
      setOptions(hourEl, hours, 12);

      const mins = [];
      for (let mm = 0; mm <= 59; mm++) mins.push({ value: mm, label: pad2(mm) });
      setOptions(minEl, mins, 0);

      updateDateMsg();
      applyTimeUnknown(false); // 기본: 시간 알고 있음
    }

    function refreshDays(y, m, preferredDay){
      const maxD = daysInMonth(y, m);
      const d = Math.min(preferredDay ?? 1, maxD);
      const days = [];
      for (let i = 1; i <= maxD; i++) days.push({ value: i, label: pad2(i) });
      setOptions(dayEl, days, d);
    }

    function updateDateMsg(){
      const y = Number(yearEl.value);
      const m = Number(monthEl.value);
      const d = Number(dayEl.value);
      dateMsg.textContent = `선택: ${y}-${pad2(m)}-${pad2(d)}`;
    }

    yearEl.addEventListener("change", ()=>{
      refreshDays(Number(yearEl.value), Number(monthEl.value), Number(dayEl.value));
      updateDateMsg();
    });
    monthEl.addEventListener("change", ()=>{
      refreshDays(Number(yearEl.value), Number(monthEl.value), Number(dayEl.value));
      updateDateMsg();
    });
    dayEl.addEventListener("change", updateDateMsg);

    // ====== Time unknown toggle ======
    function applyTimeUnknown(isUnknown){
      state.timeUnknown = isUnknown;
      unknownTimeBtn.textContent = isUnknown ? "시간 모름: ON" : "시간 모름";
      unknownTimeBtn.style.borderColor = isUnknown ? "rgba(109,94,252,.35)" : "";
      unknownTimeBtn.style.background = isUnknown ? "rgba(109,94,252,.06)" : "";
      hourEl.disabled = isUnknown;
      minEl.disabled = isUnknown;
      hourEl.style.opacity = isUnknown ? .45 : 1;
      minEl.style.opacity = isUnknown ? .45 : 1;
    }
    unknownTimeBtn.addEventListener("click", ()=>{
      applyTimeUnknown(!state.timeUnknown);
    });

    // ====== Gender toggle ======
    function setGender(g){
      state.gender = g; // "M" | "F" | ""
      gM.classList.toggle("active", g === "M");
      gF.classList.toggle("active", g === "F");
    }
    gM.addEventListener("click", ()=> setGender(state.gender === "M" ? "" : "M"));
    gF.addEventListener("click", ()=> setGender(state.gender === "F" ? "" : "F"));

    // ====== 명리 기본: 오행/음양/십신 ======
    // 오행/음양 기본 프레임(명리학 해석의 토대) :contentReference[oaicite:1]{index=1}
    const STEM_ELEMENT = { "갑":"목","을":"목","병":"화","정":"화","무":"토","기":"토","경":"금","신":"금","임":"수","계":"수" };
    const STEM_YY      = { "갑":"양","을":"음","병":"양","정":"음","무":"양","기":"음","경":"양","신":"음","임":"양","계":"음" };
    const BRANCH_ELEMENT = { "자":"수","축":"토","인":"목","묘":"목","진":"토","사":"화","오":"화","미":"토","신":"금","유":"금","술":"토","해":"수" };
    const BRANCH_YY      = { "자":"양","축":"음","인":"양","묘":"음","진":"양","사":"음","오":"양","미":"음","신":"양","유":"음","술":"양","해":"음" };

    const GEN = { "목":"화","화":"토","토":"금","금":"수","수":"목" }; // 상생
    const KEN = { "목":"토","토":"수","수":"화","화":"금","금":"목" }; // 상극(내가 극하는 대상)

    function splitPillar(p){ return { stem: p?.[0] ?? "", branch: p?.[1] ?? "" }; }

    function summarizeElements(pillars){
      const counts = { "목":0,"화":0,"토":0,"금":0,"수":0 };
      const yy = { "양":0,"음":0 };
      for (const p of pillars){
        const {stem, branch} = splitPillar(p);
        const se = STEM_ELEMENT[stem]; const be = BRANCH_ELEMENT[branch];
        const sy = STEM_YY[stem];      const by = BRANCH_YY[branch];
        if (se) counts[se]++; if (be) counts[be]++;
        if (sy) yy[sy]++; if (by) yy[by]++;
      }
      return { counts, yy };
    }
    function topEntries(obj){
      return Object.entries(obj).sort((a,b)=>b[1]-a[1]);
    }

    // 십신(십성)은 일간을 기준으로 관계를 분류하는 체계 :contentReference[oaicite:2]{index=2}
    function tenGod(dayStem, otherStem){
      const dEl = STEM_ELEMENT[dayStem];
      const oEl = STEM_ELEMENT[otherStem];
      const dYY = STEM_YY[dayStem];
      const oYY = STEM_YY[otherStem];
      if(!dEl || !oEl || !dYY || !oYY) return "";

      const sameYY = dYY === oYY;

      // 같은 오행
      if (dEl === oEl) return sameYY ? "비견" : "겁재";

      // 내가 생(생해주는) -> 식상
      if (GEN[dEl] === oEl) return sameYY ? "식신" : "상관";

      // 내가 극(극하는) -> 재성
      if (KEN[dEl] === oEl) return sameYY ? "편재" : "정재";

      // 나를 극(나를 극하는) -> 관성 (상극 역방향: other가 day를 극)
      if (KEN[oEl] === dEl) return sameYY ? "편관" : "정관";

      // 나를 생(나를 생해주는) -> 인성 (other가 day를 생)
      if (GEN[oEl] === dEl) return sameYY ? "편인" : "정인";

      return "";
    }

    function countTenGods(dayStem, stems){
      const out = {
        "비견":0,"겁재":0,"식신":0,"상관":0,"정재":0,"편재":0,"정관":0,"편관":0,"정인":0,"편인":0
      };
      for (const s of stems){
        const tg = tenGod(dayStem, s);
        if (tg) out[tg]++;
      }
      return out;
    }

    function formatTop3(counts){
      const arr = topEntries(counts).filter(([,v])=>v>0).slice(0,3);
      if(!arr.length) return "분포 정보 부족";
      return arr.map(([k,v])=>`${k} ${v}`).join(" · ");
    }

    function chip(text){
      const c = document.createElement("div");
      c.className = "chip";
      c.textContent = text;
      chipsEl.appendChild(c);
    }

    // ====== 해석(풍부하게) ======
    // 오행/음양 + 일간 + 십신 분포를 “제품형 문장”으로 길게 출력
  function interpret({ yearPillar, monthPillar, dayPillar, hourPillar, gender, timeUnknown }){
  const pillars = [yearPillar, monthPillar, dayPillar, hourPillar].filter(Boolean);
  const day = splitPillar(dayPillar);
  const dStem = day.stem;
  const dEl = STEM_ELEMENT[dStem] || "미상";
  const dYY = STEM_YY[dStem] || "미상";

  const sum = summarizeElements(pillars);
  const [strongEl, strongCnt] = topEntries(sum.counts)[0] ?? ["미상", 0];
  const yyText = `음 ${sum.yy["음"]} · 양 ${sum.yy["양"]}`;

  const stems = [
    splitPillar(yearPillar).stem,
    splitPillar(monthPillar).stem,
    splitPillar(dayPillar).stem,
    splitPillar(hourPillar).stem
  ].filter(Boolean);

  const tgCounts = countTenGods(dStem, stems.filter(s=>s && s !== dStem));
  const tgTop = formatTop3(tgCounts);

  const weak = topEntries(sum.counts).filter(([,v])=>v===0).map(([k])=>k);
  const weakHint = weak.length ? `부족해 보이는 오행: ${weak.slice(0,2).join(", ")}` : "오행이 비교적 고르게 분포된 편";

  const timeNote = timeUnknown
    ? "출생시간을 ‘모름’으로 선택해 시주(時柱) 없이 해석했습니다. 시간까지 알면 해석의 초점(대인관계/말투/리듬)이 더 선명해질 수 있습니다."
    : "출생시간을 반영해 시주(時柱)까지 포함해 해석했습니다.";

  // ✅ 용어 풀이(결과에 나온 것들을 사용자가 이해할 수 있게)
  const termExplain = `
  <h3>이번 결과 용어 풀이</h3>
  <ul>
    <li><b>년주/월주/일주/시주</b>: 사주를 4개의 기둥(태어난 해·달·날·시간)으로 나눈 것입니다. 각각 ‘환경/기본 배경’, ‘사회적 흐름/초기 습관’, ‘나의 중심(일간)’, ‘디테일한 습관/리듬’처럼 참고합니다.</li>
    <li><b>일간</b>: 일주의 ‘천간’으로, 사주에서 “나(자기 기질의 중심)”를 뜻합니다. 이번 결과는 <b>${dStem}(${dEl}, ${dYY})</b>입니다.</li>
    <li><b>오행</b>: 목·화·토·금·수 다섯 가지 에너지 균형입니다. 이번 결과에서 가장 두드러진 오행은 <b>${strongEl}</b>(${strongCnt})로 보입니다.</li>
    <li><b>음양</b>: 에너지 성향의 방향입니다. 양은 ‘외향/속도/직진’, 음은 ‘내향/정교/축적’으로 이해하면 쉽습니다. 이번 결과는 <b>${yyText}</b>입니다.</li>
    <li><b>십신</b>: 일간 기준으로 다른 천간과의 관계를 분류한 역할(비견/겁재/식신/상관/정재/편재/정관/편관/정인/편인)입니다. 이번 결과의 간단 분포는 <b>${tgTop}</b>입니다.</li>
  </ul>
  <p class="small">${timeNote}</p>
  `.trim();

  // ✅ 전망 문장: “단정” 대신 “경향/가능성 + 행동”으로
  function outlookTemplate(topic){
    const strongLine =
      strongEl === "미상" ? "현재 정보만으로는 한쪽 오행이 과하게 치우쳤다고 보긴 어렵습니다."
      : `강한 오행(${strongEl}) 성향이 뚜렷하면 장점이 빨리 성과로 연결되지만, 과하면 피로/조급/고집으로 보일 수 있습니다.`;

    const balanceLine =
      weak.length ? `${weakHint} → 이 쪽을 ‘습관’으로 채우면 전체 흐름이 안정됩니다.` : "균형이 비교적 좋아서 ‘루틴 유지’가 곧 실력입니다.";

    const near = `
    <h3>가까운 흐름(전망)</h3>
    <ul>
      <li>${strongLine}</li>
      <li>${balanceLine}</li>
      <li><b>핵심 포인트:</b> “결정→실행→피드백” 사이클을 짧게 가져가면 운의 체감이 커집니다.</li>
    </ul>`;

    const mid = `
    <h3>중기 흐름(전망)</h3>
    <ul>
      <li><b>좋아지는 패턴:</b> 기준과 루틴이 쌓일수록 결과가 따라오는 타입으로 해석됩니다.</li>
      <li><b>흔한 변수:</b> 에너지 과부하(과몰입/속도)로 관계·업무에서 소진이 생기면 흐름이 흔들릴 수 있습니다.</li>
      <li><b>추천 전략:</b> ${topic}에서 “과한 부분을 줄이기”보다 “균형을 만드는 장치(일정·메모·대화 규칙)”를 두는 게 효과적입니다.</li>
    </ul>`;

    return (near + mid).trim();
  }

  const action3 = (a,b,c)=>`
    <h3>오늘의 실천 3가지</h3>
    <ul>
      <li>${a}</li>
      <li>${b}</li>
      <li>${c}</li>
    </ul>
  `.trim();

  // ====== 성향/성격 ======
  const personality = `
  <h3>핵심 요약</h3>
  <ul>
    <li><b>일간(나의 중심):</b> ${dStem}(${dEl}, ${dYY})</li>
    <li><b>강한 오행:</b> ${strongEl}${strongCnt ? `(${strongCnt})` : ""}</li>
    <li><b>음양:</b> ${yyText}</li>
    <li><b>십신(간단):</b> ${tgTop}</li>
  </ul>

  ${termExplain}

  <h3>성향/성격 해석</h3>
  <ul>
    <li><b>${dEl}</b> 기질은 “내 기준/방향”이 잡히면 추진력이 강해지고, 기준이 흐트러지면 에너지가 분산되기 쉽습니다.</li>
    <li><b>${dYY}</b> 성향은 의사결정 방식에 드러납니다. 양이면 빠른 결단, 음이면 정교한 검토에 강점이 있습니다.</li>
    <li><b>${strongEl}</b>이 강하면 해당 기질의 장점(몰입/속도/집중)이 도드라지지만, 과하면 반대로 (조급/고집/과몰입)으로 보일 수 있습니다.</li>
  </ul>

  ${outlookTemplate("자기관리")}

  ${action3(
    "오늘 결정할 일 1개를 ‘기준 한 줄’로 써보기(왜 하는지).",
    "하루 루틴에 ‘멈춤 10분(정리/산책/호흡)’을 넣어 에너지 과부하를 줄이기.",
    "일/관계에서 ‘내 말 한 줄 요약 → 상대 확인’ 습관 만들기."
  )}
  `.trim();

  // ====== 직업운 ======
  const career = `
  <h3>직업운 핵심</h3>
  <ul>
    <li><b>잘 맞는 업무:</b> 기준이 명확한 목표형 업무(프로젝트/KPI) 또는 프로세스를 다듬는 운영·기획·관리형 업무</li>
    <li><b>강점이 나는 방식:</b> 한 번 기준을 잡고 꾸준히 밀어붙이는 힘 + 결과로 설득</li>
    <li><b>주의 포인트:</b> 속도가 붙을수록 검토/공유가 늦어지면 리스크가 커질 수 있음</li>
  </ul>

  ${termExplain}

  <h3>직업운 해석(제품형)</h3>
  <ul>
    <li><b>강한 오행(${strongEl})</b>은 “일을 당기는 엔진”이 될 수 있습니다. 이 엔진을 <b>문서/일정/체크리스트</b>로 고정하면 성과가 안정화됩니다.</li>
    <li><b>십신(${tgTop})</b>은 업무 성향 힌트입니다. 예를 들어 ‘식상’ 쪽은 표현/성과, ‘관성’은 책임/규칙, ‘인성’은 학습/지원 성향으로 풀이할 수 있습니다.</li>
  </ul>

  ${outlookTemplate("커리어")}

  ${action3(
    "이번 달 목표 1개를 ‘측정 가능’하게 바꾸기(예: 3건 완료/1회 개선).",
    "작업 전 체크 3개(목표/리스크/공유타이밍) 적고 시작하기.",
    "주 1회 ‘내가 만든 개선 1개’ 기록해서 누적하기."
  )}
  `.trim();

  // ====== 연애·결혼운 ======
  const love = `
  <h3>연애·결혼운 핵심</h3>
  <ul>
    <li><b>관계의 키:</b> 리듬 조율(속도/표현/경계)</li>
    <li><b>표현 스타일 힌트:</b> ${dYY} 성향은 말의 템포와 감정 표현 방식에 영향을 줍니다.</li>
    <li><b>흔한 변수:</b> 강한 오행(${strongEl})이 과해지면 ‘내 방식이 정답’이 되기 쉬움</li>
  </ul>

  ${termExplain}

  <h3>연애·결혼운 해석</h3>
  <ul>
    <li>잘 맞는 관계는 “약속/기준을 대화로 맞추는 관계”입니다(연락 빈도, 시간 사용, 가치관).</li>
    <li>감정이 커질 때는 결론을 내기 전에 “상대 감정 확인 → 내 감정 설명” 순서로 가면 안정적입니다.</li>
  </ul>

  ${outlookTemplate("관계")}

  ${action3(
    "갈등이 생기면 ‘상대 말 1문장 요약 → 맞는지 확인’부터 하기.",
    "연애/결혼에서 중요하게 보는 기준 3개를 적고, 대화 가능한 문장으로 바꾸기.",
    "서로 피로 신호(말수/표정/회피)를 정해두고, 쉬는 규칙 만들기."
  )}

  <p class="small">${gender ? `선택 성별: ${gender === "M" ? "남" : "여"} (현재 MVP는 문장 톤 조정에만 사용)` : "성별 미선택(중립 톤)"} </p>
  `.trim();

  return { personality, career, love, sum, dStem, dEl, dYY, strongEl, tgCounts, timeUnknown };
}

    function setPanel(key){
      tabs.forEach(t => t.classList.toggle("active", t.dataset.tab === key));
      if(!state.interpretation) return;
      panel.innerHTML = state.interpretation[key];
    }
    tabs.forEach(t => t.addEventListener("click", ()=> setPanel(t.dataset.tab)));

    function resetAll(){
      msg.textContent = "";
      resultCard.style.display = "none";
      interpretCard.style.display = "none";
      chipsEl.innerHTML = "";
      techNote.textContent = "";
      state.interpretation = null;
      setGender("");
      applyTimeUnknown(false);

      // 날짜는 오늘로
      const now = new Date();
      yearEl.value = String(now.getFullYear());
      monthEl.value = String(now.getMonth()+1);
      refreshDays(Number(yearEl.value), Number(monthEl.value), now.getDate());
      updateDateMsg();

      hourEl.value = "12";
      minEl.value = "0";
    }
    resetBtn.addEventListener("click", resetAll);

    // ====== Run ======
    runBtn.addEventListener("click", ()=>{
      msg.textContent = "";

      const Y = Number(yearEl.value);
      const M = Number(monthEl.value);
      const D = Number(dayEl.value);

      if(!Y || !M || !D){
        msg.innerHTML = '<span class="error">생년월일을 먼저 선택해 주세요.</span>';
        return;
      }

      let hour = undefined, minute = 0;
      if(!state.timeUnknown){
        hour = Number(hourEl.value);
        minute = Number(minEl.value);
      }

      try{
        // longitude/time correction은 라이브러리 옵션(기본적으로 일정 보정이 적용될 수 있음)
        const r = calculateSaju(Y, M, D, hour, minute, { longitude: 127, applyTimeCorrection: true });

        // 표 출력
        document.getElementById("y").textContent = r.yearPillar ?? "-";
        document.getElementById("m").textContent = r.monthPillar ?? "-";
        document.getElementById("d").textContent = r.dayPillar ?? "-";
        document.getElementById("h").textContent = state.timeUnknown ? "모름" : (r.hourPillar ?? "-");

        // 칩(오행/음양/일간/십신 요약)
        chipsEl.innerHTML = "";
        const sum = summarizeElements([r.yearPillar, r.monthPillar, r.dayPillar, r.hourPillar].filter(Boolean));
        const topEl = topEntries(sum.counts)[0];
        const dayStem = splitPillar(r.dayPillar).stem;

        chip(`일간: ${dayStem}(${STEM_ELEMENT[dayStem] ?? "?"}, ${STEM_YY[dayStem] ?? "?"})`);
        chip(`강한 오행: ${topEl?.[1] ? `${topEl[0]}(${topEl[1]})` : "정보 부족"}`);
        chip(`음양: 음 ${sum.yy["음"]} · 양 ${sum.yy["양"]}`);

        // 십신(간단) 분포
        const stems = [splitPillar(r.yearPillar).stem, splitPillar(r.monthPillar).stem, splitPillar(r.dayPillar).stem, splitPillar(r.hourPillar).stem].filter(Boolean);
        const tgCounts = countTenGods(dayStem, stems.filter(s=>s && s !== dayStem));
        chip(`십신: ${formatTop3(tgCounts)}`);

        resultCard.style.display = "";
        interpretCard.style.display = "";

        // 해석 생성
        state.interpretation = interpret({
          yearPillar: r.yearPillar,
          monthPillar: r.monthPillar,
          dayPillar: r.dayPillar,
          hourPillar: state.timeUnknown ? "" : (r.hourPillar ?? ""),
          gender: state.gender,
          timeUnknown: state.timeUnknown
        });

        // 기본 탭
        setPanel("personality");

        // 기술 노트
        techNote.textContent =
          state.timeUnknown
            ? "출생시간을 모름으로 선택해 시주 없이 해석했습니다."
            : (r.isTimeCorrected ? "시간 보정이 적용될 수 있습니다(라이브러리 옵션)." : "시간 보정 미적용");

      }catch(e){
        msg.innerHTML = `<span class="error">계산에 실패했습니다. 선택 값이 올바른지 확인해 주세요.</span>`;
        console.error(e);
      }
    });

    // ====== Init ======
    initPickers();
    resetAll();

    // 참고: 오행/음양 및 십신 개념은 명리학에서 널리 쓰이는 기본 프레임입니다. :contentReference[oaicite:4]{index=4}
  </script>
</body>
</html>

